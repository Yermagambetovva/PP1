Вот код, в котором вместо `scanf` и `printf` используются стандартные потоки ввода-вывода `cin` и `cout`:

---

### Код:

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n, mx;
    cin >> n; // Считываем количество интервалов
    mx = n;   // Изначально предполагаем, что все точки работают

    // Массив для учета количества работающих точек в каждую минуту суток
    vector<vector<int>> time(24, vector<int>(60, 0));

    // Обрабатываем каждый интервал
    while (n--) {
        int t[4]; // Массив для хранения четырех чисел: часы и минуты начала и конца интервала
        for (int i = 0; i < 4; i++) {
            cin >> t[i]; // Считываем значения t[0], t[1], t[2], t[3]
        }

        // Если магазин работает круглосуточно (начало совпадает с концом)
        if (t[0] == t[2] && t[1] == t[3]) {
            mx--; // Уменьшаем количество точек, которые нужно учитывать
            continue; // Пропускаем обработку этого интервала
        }

        // Если конец интервала раньше начала, добавляем 24 часа к концу
        if (t[0] > t[2]) {
            t[2] += 24;
        }

        // Заполняем минуты для часов в интервале от t[0] до t[2] - 1
        for (int h = t[0]; h < t[2]; h++) {
            int startMinute = (h == t[0]) ? t[1] : 0; // Начальная минута для первого часа
            int endMinute = 60; // Конечная минута для часа
            for (int m = startMinute; m < endMinute; m++) {
                time[h % 24][m]++; // Увеличиваем счетчик для каждой минуты
            }
        }

        // Обрабатываем минуты последнего часа
        int lastHour = t[2] % 24;
        int startMinute = (t[0] == t[2]) ? t[1] : 0; // Начальная минута (если это единственный час)
        for (int m = startMinute; m < t[3]; m++) {
            time[lastHour][m]++;
        }
    }

    // Подсчет количества минут, когда все точки работают одновременно
    int res = 0;
    for (int h = 0; h < 24; h++) { // Проходим по каждому часу
        for (int m = 0; m < 60; m++) { // По каждой минуте
            if (time[h][m] == mx) { // Если количество работающих точек равно mx
                res++;
            }
        }
    }

    cout << res << endl; // Выводим результат
    return 0;
}
```

---

### Объяснение изменений:
1. **Замена `scanf` и `printf`:**
   - `cin >> t[i]` заменяет `scanf`.
   - `cout << res << endl` заменяет `printf`.

2. **Использование `vector`:**
   - Массив `time` заменён на `vector` для большей гибкости (не обязательно, но полезно для старых компиляторов).

3. **Логика осталась неизменной:**
   - Обрабатываются интервалы, включая пересечение через полночь.
   - Круглосуточные магазины исключаются из расчётов.

---

### Пример ввода:
```
3
1 0 23 0
12 0 12 0
22 0 2 0
```

### Пример вывода:
```
120
```

---

### Сложность:
- **Временная сложность:** \(O(n \times (t[2] - t[0]))\), где \(n\) — количество интервалов.
- **Пространственная сложность:** \(O(24 \times 60)\), так как используется двумерный массив/вектор.

Код прост и полностью совместим с более старыми версиями C++!