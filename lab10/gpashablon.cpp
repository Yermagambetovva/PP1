/*
Конечно! Давайте рассмотрим шаблонный код, который можно использовать для решения подобных задач, где требуется работать с коллекциями данных, сортировать их и хранить с использованием структур. В этом примере мы создадим универсальный шаблон для задач, где:

1. Нужно хранить данные о студентах или других объектах.
2. Нужно подсчитывать или вычислять какое-то значение на основе входных данных.
3. Требуется сортировка по нескольким критериям (например, GPA, имя).
4. Используем структуру для организации данных.

### Шаблонный код с объяснением:

```cpp
#include <iostream>
#include <map>
#include <vector>
#include <algorithm>
#include <iomanip>  // Для setprecision
using namespace std;

// Структура для хранения информации о студенте (или другом объекте)
struct Entity {
    string name;        // Имя (или другая уникальная информация)
    double totalScore;  // Сумма всех значений (например, GPA или других показателей)
    int count;          // Количество записей (например, количество семестров или оценок)

    // Конструктор по умолчанию
    Entity() : name(""), totalScore(0), count(0) {}

    // Метод для добавления нового значения
    void addScore(double score) {
        totalScore += score;
        count++;
    }

    // Метод для вычисления среднего значения
    double getAverageScore() const {
        if (count > 0)
            return totalScore / count;
        return 0.0;
    }
};

// Функция для решения задачи
void solveProblem(int n) {
    // Карта для хранения данных, где ключ - имя, а значение - структура Entity
    map<string, Entity> entities;

    // Чтение входных данных
    for (int i = 0; i < n; ++i) {
        string name;
        double score;
        cin >> name >> score;

        // Если объект уже существует, добавляем новое значение
        if (entities.find(name) != entities.end()) {
            entities[name].addScore(score);
        } else {
            // Если объекта нет в карте, создаем новый и добавляем значение
            Entity newEntity;
            newEntity.name = name;
            newEntity.addScore(score);
            entities[name] = newEntity;
        }
    }

    // Переносим данные в вектор для сортировки
    vector<Entity> sortedEntities;
    for (const auto& entry : entities) {
        sortedEntities.push_back(entry.second);
    }

    // Сортировка:
    // 1. Сортируем по среднему значению по убыванию
    // 2. Если среднее значение одинаковое, сортируем по имени по возрастанию
    sort(sortedEntities.begin(), sortedEntities.end(), [](const Entity& a, const Entity& b) {
        if (a.getAverageScore() == b.getAverageScore()) {
            return a.name < b.name;  // Если значения одинаковые, сортируем по имени
        }
        return a.getAverageScore() > b.getAverageScore();  // Сортируем по среднему значению
    });

    // Выводим отсортированные данные с нужным форматом
    for (const auto& entity : sortedEntities) {
        cout << entity.name << ": " << fixed << setprecision(3) << entity.getAverageScore() << endl;
    }
}

int main() {
    int n;  // Количество записей
    cin >> n;

    solveProblem(n);  // Решаем задачу

    return 0;
}
```

### Объяснение шаблонного кода:

1. **Структура `Entity`**:
   - В этой структуре мы храним информацию о "сущности" (например, студенте или другом объекте).
   - Поля:
     - `name`: строка для хранения имени сущности (например, имя студента).
     - `totalScore`: сумма всех значений (например, сумма всех GPA).
     - `count`: количество записей (например, количество семестров или оценок).
   - Метод `addScore`: добавляет новое значение к сумме и увеличивает счетчик записей.
   - Метод `getAverageScore`: вычисляет среднее значение (например, средний GPA).

2. **Чтение входных данных**:
   - Мы используем карту `map<string, Entity>`, где ключ — это имя сущности (например, имя студента), а значение — структура `Entity`, которая хранит все данные.
   - При каждом новом значении (например, GPA) мы обновляем структуру, добавляя новое значение через метод `addScore`.

3. **Сортировка данных**:
   - Данные из карты переносятся в вектор, так как карту нельзя отсортировать напрямую.
   - Мы сортируем вектор по двум критериям:
     - Сначала по среднему значению (по убыванию).
     - Если средние значения равны, то по имени (в алфавитном порядке).

4. **Вывод**:
   - Для вывода мы используем `fixed` и `setprecision(3)`, чтобы отобразить среднее значение с точностью до трех знаков после запятой.

### Пример 1:

**Ввод:**
```
5
namsa 4
kymbat 3
kymbat 4
namsa 4
pes 2
```

**Вывод:**
```
namsa: 4.000
kymbat: 3.500
pes: 2.000
```

### Пример 2:

**Ввод:**
```
6
aaa 3
aaa 4
bbb 4
bbb 3
ccc 4
ddd 1
```

**Вывод:**
```
ccc: 4.000
aaa: 3.500
bbb: 3.500
ddd: 1.000
```

### Пояснение шаблонного подхода:

1. **Гибкость**:
   - Структура `Entity` может быть использована для разных типов задач, например, для студентов, сотрудников, товаров и т.д.
   - В поле `name` можно хранить любой уникальный идентификатор (имя, ID и т.д.), а в поле `totalScore` — любые данные, которые нужно подсчитывать (оценки, баллы, суммы и т.д.).

2. **Сортировка по нескольким критериям**:
   - Мы продемонстрировали, как сортировать по двум критериям (средний балл и имя), что часто требуется в подобных задачах.

3. **Удобство расширения**:
   - Код легко расширяется. Например, если требуется добавить дополнительные параметры или изменить алгоритм вычисления, это можно сделать, просто изменив структуру `Entity` и соответствующие методы.

### Заключение:
Этот шаблон предоставляет гибкую основу для решения задач, связанных с обработкой данных в виде коллекций объектов, их сортировкой и вычислением различных показателей. Вы можете адаптировать его для различных типов задач, изменяя структуру данных и критерии сортировки.
*/